<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>VYZ Interstellar: Focus Protocol</title>
    
    <link rel="icon" type="image/png" href="/ReVYZGen-Game/favicon.png">

    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700;900&family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            font-family: 'Rajdhani', sans-serif;
            color: #fff;
            user-select: none;
            cursor: none; 
            touch-action: none; /* Prevents browser pull-to-refresh and scrolling */
        }

        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            background: #000;
            transition: background 1s;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .hud-text {
            font-family: 'Orbitron', sans-serif;
            text-shadow: 0 0 10px #00ffff;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-size: 12px;
            font-weight: 700;
        }

        .counter-big {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(24px, 8vw, 40px);
            font-weight: 700;
            color: #fff;
            text-shadow: 0 0 20px #00ffff;
            transition: color 0.5s, text-shadow 0.5s;
        }

        #awareness-meter {
            width: 100%;
            height: 2px;
            background: rgba(0, 255, 255, 0.1);
            margin-top: 10px;
            position: relative;
        }

        #awareness-fill {
            height: 100%;
            background: #00ffff;
            width: 0%;
            box-shadow: 0 0 10px #00ffff;
            transition: width 0.2s, background 0.5s, box-shadow 0.5s;
        }

        #central-message {
            position: absolute;
            top: 20%; 
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            opacity: 0;
            transition: opacity 0.5s;
            width: 100%;
            pointer-events: none;
        }

        #central-message h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(20px, 6vw, 32px);
            margin: 0;
            color: #00ffff;
            text-shadow: 0 0 20px #00ffff;
            letter-spacing: 3px;
        }

        #central-message p {
            font-size: 14px;
            color: #fff;
            margin-top: 5px;
            text-shadow: 0 0 5px #fff;
            font-weight: 700;
            text-transform: uppercase;
            opacity: 0.8;
        }

        #start-screen, #end-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            transition: opacity 1s;
            cursor: default;
        }
        
        #end-screen {
            display: none;
            background: #000;
        }

        .logo-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px; 
            margin-bottom: 20px;
            align-items: center;
            padding: 0 20px;
        }

        .logo-block {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative; 
        }

        .logo-main {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(32px, 10vw, 60px);
            font-weight: 900;
            background: linear-gradient(180deg, #ffffff 30%, #0088ff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 40px rgba(0, 255, 255, 0.3);
            letter-spacing: 0px;
            line-height: 1;
            text-align: center;
        }
        
        #staged-intro-area {
            position: relative;
            height: 120px; 
            width: 90vw;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .intro-stage, .intro-stage-highlight, .intro-stage-title {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%; 
            font-family: 'Orbitron', sans-serif; 
            font-size: clamp(14px, 4.5vw, 22px); 
            font-weight: 700; 
            color: #fff;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            text-transform: uppercase;
            letter-spacing: clamp(1px, 0.5vw, 3px);
            opacity: 0;
            transition: opacity 2.0s ease-in-out, color 2.0s ease-in-out, text-shadow 2.0s ease-in-out; 
            text-align: center;
            padding: 0 10px;
            box-sizing: border-box;
        }

        .intro-detail {
            display: block;
            font-size: 0.65em;
            opacity: 0.6;
            letter-spacing: 5px;
            margin-top: 8px;
            font-weight: 500;
        }

        /* BUTTONS */
        .btn-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            margin-top: 30px;
        }

        .start-btn {
            padding: 16px clamp(30px, 10vw, 60px);
            font-size: clamp(14px, 4vw, 18px);
            background: transparent;
            color: #00ffff;
            border: 2px solid #00ffff;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 4px;
            transition: all 0.3s;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.1);
        }

        .start-btn:hover {
            background: #00ffff;
            color: #000;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.8);
        }

        .cortex-btn {
            padding: 18px 50px;
            background: #ffd700;
            color: #000;
            border: none;
            font-family: 'Orbitron', sans-serif;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 3px;
            cursor: pointer;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.4);
            transition: all 0.3s;
            display: none; /* Only visible on win */
        }

        .cortex-btn:hover {
            box-shadow: 0 0 60px rgba(255, 215, 0, 0.8);
            transform: scale(1.05);
        }

        .secondary-btn {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 8px 20px;
            background: transparent;
            cursor: pointer;
            text-transform: uppercase;
            font-family: 'Orbitron', sans-serif;
            transition: all 0.3s;
            letter-spacing: 2px;
        }

        .secondary-btn:hover {
            color: #fff;
            border-color: #fff;
            background: rgba(255, 255, 255, 0.05);
        }

        #loader {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            color: #555;
            font-family: 'Rajdhani', sans-serif;
        }

    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="game-container"></div>

    <div id="ui-layer">
        <div class="hud-top">
            <div>
                <div class="hud-text">Target Protocol</div>
                <div class="counter-big"><span id="caught-count">0</span> / 100</div>
            </div>
        </div>
        
        <div id="central-message">
            <h1 id="msg-title"></h1>
            <p id="msg-sub"></p>
        </div>

        <div style="width: 100%; text-align: center; margin-bottom: 20px;">
            <div id="awareness-meter"><div id="awareness-fill"></div></div>
        </div>
    </div>

    <div id="start-screen">
        <div id="staged-intro-area">
            <div id="intro-line-1" class="intro-stage">PREPARING LAUNCH SEQUENCE...</div>
            <div id="intro-line-2" class="intro-stage intro-stage-highlight"></div>
            <div id="intro-title" class="intro-stage-title"></div>
        </div>
        
        <button class="start-btn" id="initial-start-btn" style="opacity: 0; pointer-events: none; margin-top: 100px;">
            Initiate Protocol
        </button>

        <div id="loader">Calibrating Physics Engine...</div>
    </div>

    <div id="end-screen">
        <div class="logo-container">
            <div class="logo-block"><div class="logo-main" id="end-title-1" style="font-size: clamp(30px, 8vw, 40px);">SEQUENCE</div></div>
            <div class="logo-block"><div class="logo-main" id="end-title-2" style="font-size: clamp(30px, 8vw, 40px);">INCOMPLETE</div></div>
        </div>
        
        <div id="end-message" style="margin-bottom: 10px;"></div>
        <div id="ai-insight" style="margin-bottom: 20px; color: #fff; max-width: 500px; text-align: center; padding: 0 20px; font-weight: 700; letter-spacing: 2px; text-transform: uppercase;"></div>
        
        <div class="btn-container">
            <button class="cortex-btn" id="connect-cortex-btn">Connect to Cortex</button>
            <button class="start-btn" id="restart-btn">Re-Initiate Protocol</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        const ACHIEVEMENT_TITLES = ["SYNC 20%", "SYNC 40%", "SYNC 60%", "SYNC 80%", "SYNC 90%"];
        const ACHIEVEMENT_SUBS = ["ALIGNMENT STABLE", "VELOCITY INCREASING", "FOCUS LOCKED", "REALITY BENDING", "ASCENSION IMMINENT"];

        const CONFIG = {
            colors: { neonBlue: 0x00ffff, neonRed: 0xff0033, white: 0xffffff, gold: 0xffd700, void: 0x000000 },
            baseSpeed: 1.1,
            maxSpeed: 3.5,
            totalCrystals: 100,
            winnerEmail: 'cortex@vyzinterstellar.com'
        };

        let scene, camera, renderer, composer, bloomPass, clock;
        let player, playerCore, tunnel, vyztor, starSystem, spaceDebris, highSpeedParticles;
        let crystals = []; 
        let particleSystems = [];
        let debrisObjects = [];
        let tunnelMaxPoints = 0;

        let isPlaying = false;
        let isAscending = false;
        let crystalsSpawned = 0;
        let crystalsCaught = 0;
        let currentSpeed = CONFIG.baseSpeed;
        let gameTime = 0;
        let mouse = new THREE.Vector2();
        let targetPosition = new THREE.Vector2();
        let shakeIntensity = 0;
        let currentStage = 0; 
        let nextSpawnCooldown = 0; 
        let bounds = { x: 10, y: 7 }; 

        // Touch handling variables for relative movement
        let isTouching = false;
        let lastTouchX = 0;
        let lastTouchY = 0;

        function init() {
            const container = document.getElementById('game-container');

            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(CONFIG.colors.void, 0.015);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 8;
            camera.position.y = 0;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ReinhardToneMapping;
            renderer.toneMappingExposure = 1.5;
            container.appendChild(renderer.domElement);

            clock = new THREE.Clock();

            const renderScene = new RenderPass(scene, camera);
            bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.1;
            bloomPass.strength = 2.0;
            bloomPass.radius = 0.6;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            scene.add(new THREE.AmbientLight(0x111111));
            const pointLight = new THREE.PointLight(CONFIG.colors.neonBlue, 2, 100);
            pointLight.position.set(0, 5, 10);
            scene.add(pointLight);

            createPlayer();
            createTunnel();
            createVyztor();
            createStars();
            createSpaceDebris();
            createHighSpeedParticles();
            
            calculateGameBounds();

            // Event Listeners
            document.addEventListener('mousemove', onMouseMove);
            
            // Modern Touch Listeners
            document.addEventListener('touchstart', onTouchStart, { passive: false });
            document.addEventListener('touchmove', onTouchMove, { passive: false });
            document.addEventListener('touchend', onTouchEnd, { passive: false });
            
            window.addEventListener('resize', onWindowResize);

            animate();
            document.getElementById('loader').style.display = 'none';
            setTimeout(runIntroSequence, 500);
        }

        function runIntroSequence() {
            const line1 = document.getElementById('intro-line-1');
            const line2 = document.getElementById('intro-line-2');
            const title = document.getElementById('intro-title');
            const introArea = document.getElementById('staged-intro-area');

            const VISIBLE_TIME = 2000; 
            const GAP_TIME = 1000; 
            
            let totalDelay = 0;
            
            setTimeout(() => { line1.style.opacity = 1; }, totalDelay);
            totalDelay += 2000 + VISIBLE_TIME;

            setTimeout(() => { line1.style.opacity = 0; }, totalDelay);
            totalDelay += 2000 + GAP_TIME;

            setTimeout(() => {
                line2.innerHTML = `FOCUS REQUIRED <span class="intro-detail">100 FRAGMENTS</span>`;
                line2.style.opacity = 1;
            }, totalDelay);
            totalDelay += 2000 + VISIBLE_TIME;

            setTimeout(() => { line2.style.opacity = 0; }, totalDelay);
            totalDelay += 2000 + GAP_TIME;

            setTimeout(() => {
                title.innerText = "VYZ INTERSTELLAR";
                title.style.opacity = 1;
                setTimeout(() => {
                    title.style.color = '#00ffff';
                    title.style.textShadow = '0 0 10px #00ffff, 0 0 20px #00ffff';
                }, 500);
            }, totalDelay);
            totalDelay += 2000 + VISIBLE_TIME;

            setTimeout(() => { title.style.opacity = 0; }, totalDelay);
            totalDelay += 2000; 

            setTimeout(() => {
                introArea.style.display = 'none';
                let t = 0;
                const duration = 180; 
                const maxPoints = tunnelMaxPoints;
                
                const fadeTunnel = () => {
                    if (t < duration) {
                        t++;
                        const drawCount = Math.floor((t / duration) * maxPoints); 
                        tunnel.children.forEach(l => {
                            l.geometry.setDrawRange(0, drawCount);
                        });
                        requestAnimationFrame(fadeTunnel);
                    } else {
                        tunnel.children.forEach(l => l.geometry.setDrawRange(0, maxPoints));
                        const startBtn = document.getElementById('initial-start-btn');
                        startBtn.style.opacity = 1;
                        startBtn.style.pointerEvents = 'auto';
                    }
                };
                fadeTunnel();
            }, totalDelay);
        }

        function startProtocol() {
            if (isPlaying) return;
            document.getElementById('start-screen').style.opacity = 0;
            setTimeout(() => document.getElementById('start-screen').style.display = 'none', 1000);
            
            crystals.forEach(c => scene.remove(c));
            crystals = [];
            particleSystems.forEach(p => scene.remove(p));
            particleSystems = [];
            crystalsSpawned = 0;
            crystalsCaught = 0;
            currentSpeed = CONFIG.baseSpeed;
            currentStage = -1; 
            isAscending = false;
            camera.fov = 75;
            camera.updateProjectionMatrix();
            bloomPass.strength = 2.0;

            calculateDifficulty();
            updateHUD();
            
            mouse.x = 0; mouse.y = 0;
            isPlaying = true;
            nextSpawnCooldown = 1; 
            clock.start();
        }

        function calculateGameBounds() {
            const dist = camera.position.z; 
            const vFOV = THREE.MathUtils.degToRad(camera.fov); 
            const visibleHeight = 2 * Math.tan(vFOV / 2) * dist;
            const visibleWidth = visibleHeight * camera.aspect;
            bounds.y = (visibleHeight / 2) - 0.8; 
            bounds.x = (visibleWidth / 2) - 0.8;
        }

        function createPlayer() {
            player = new THREE.Group();
            const coreGeo = new THREE.IcosahedronGeometry(0.4, 4);
            const coreMat = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.white, emissive: CONFIG.colors.neonBlue,
                emissiveIntensity: 1, roughness: 0.3, metalness: 0.8, wireframe: true 
            });
            playerCore = new THREE.Mesh(coreGeo, coreMat);
            player.add(playerCore);
            
            for(let i=0; i<3; i++) {
                const arcGeo = new THREE.TorusGeometry(0.7 + (i*0.1), 0.02, 16, 32, Math.PI + Math.random());
                const arcMat = new THREE.MeshBasicMaterial({ color: CONFIG.colors.neonBlue, transparent: true, opacity: 0.6 });
                const arc = new THREE.Mesh(arcGeo, arcMat);
                arc.rotation.x = Math.PI / 2;
                arc.rotation.z = (Math.PI * 2 / 3) * i;
                arc.userData = { rotSpeed: (Math.random() - 0.5) * 0.05 };
                player.add(arc);
            }
            scene.add(player);
        }

        function createTunnel() {
            tunnel = new THREE.Group();
            const lineCount = 40; 
            const segments = 100;
            tunnelMaxPoints = segments;

            for(let i = 0; i < lineCount; i++) {
                const angle = (i / lineCount) * Math.PI * 2;
                const radius = 12; 
                const points = [];
                for(let j = 0; j < segments; j++) {
                    const twist = j * 0.08; 
                    points.push(new THREE.Vector3(
                        Math.cos(angle + twist) * radius, 
                        Math.sin(angle + twist) * radius, 
                        -j * 8
                    ));
                }
                const geo = new THREE.BufferGeometry().setFromPoints(points);
                const mat = new THREE.LineBasicMaterial({ 
                    color: CONFIG.colors.neonBlue, transparent: true, opacity: 0.3, linewidth: 1
                });
                const line = new THREE.Line(geo, mat);
                line.geometry.setDrawRange(0, 0); 
                tunnel.add(line);
            }
            scene.add(tunnel);
        }

        function createVyztor() {
            const geometry = new THREE.OctahedronGeometry(40, 1);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0x000000, emissive: CONFIG.colors.neonBlue, emissiveIntensity: 0.2,
                wireframe: true, transparent: true, opacity: 0.5,
            });
            vyztor = new THREE.Mesh(geometry, material);
            vyztor.position.z = -500;
            scene.add(vyztor);
        }

        function createStars() {
            const geo = new THREE.BufferGeometry();
            const pos = [];
            for (let i = 0; i < 3000; i++) {
                pos.push((Math.random()-0.5)*1000, (Math.random()-0.5)*1000, -Math.random()*1000);
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            starSystem = new THREE.Points(geo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.5, transparent: true, opacity: 0.5 }));
            scene.add(starSystem);
        }

        function createSpaceDebris() {
            for(let i=0; i<30; i++) {
                const size = 1 + Math.random() * 2;
                const mesh = new THREE.Mesh(new THREE.TetrahedronGeometry(size), new THREE.MeshBasicMaterial({ color: 0x333333, wireframe: true, transparent: true, opacity: 0 }));
                const r = 25 + Math.random() * 20;
                const theta = Math.random() * Math.PI * 2;
                mesh.position.set(r * Math.cos(theta), r * Math.sin(theta), (Math.random() - 0.5) * 800);
                mesh.userData = { rotSpeed: (Math.random()-0.5) * 0.05 };
                scene.add(mesh);
                debrisObjects.push(mesh);
            }
        }

        function createHighSpeedParticles() {
            const geo = new THREE.BufferGeometry();
            const pos = [];
            for (let i = 0; i < 800; i++) {
                const r = 15 + Math.random() * 40;
                const theta = Math.random() * Math.PI * 2;
                pos.push(r * Math.cos(theta), r * Math.sin(theta), (Math.random() - 0.5) * 1000);
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            highSpeedParticles = new THREE.Points(geo, new THREE.PointsMaterial({ color: 0xccffff, size: 0.8, transparent: true, opacity: 0, blending: THREE.AdditiveBlending }));
            scene.add(highSpeedParticles);
        }

        function onMouseMove(e) {
            if (document.pointerLockElement === document.body) {
                const sensitivityX = 2.0 / window.innerWidth * 1.5;
                const sensitivityY = 2.0 / window.innerHeight * 1.5;
                mouse.x = Math.max(-1, Math.min(1, mouse.x + e.movementX * sensitivityX));
                mouse.y = Math.max(-1, Math.min(1, mouse.y - e.movementY * sensitivityY));
            } else if (!isTouching) {
                // Only use absolute mapping if not on mobile/touching
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            }
        }

        // TOUCH HANDLING: Relative Movement Logic
        function onTouchStart(e) {
            if (e.touches.length > 0) {
                isTouching = true;
                lastTouchX = e.touches[0].clientX;
                lastTouchY = e.touches[0].clientY;
            }
        }

        function onTouchMove(e) {
            if (e.touches.length > 0 && isPlaying) {
                e.preventDefault();
                
                const touch = e.touches[0];
                const dx = touch.clientX - lastTouchX;
                const dy = touch.clientY - lastTouchY;

                // Sensitivity factor: High enough to reach corners easily
                const sensitivity = 2.5 / Math.min(window.innerWidth, window.innerHeight);

                // Update normalized mouse coordinates relatively
                mouse.x += dx * sensitivity;
                mouse.y -= dy * sensitivity;

                // Clamp values between -1 and 1
                mouse.x = Math.max(-1, Math.min(1, mouse.x));
                mouse.y = Math.max(-1, Math.min(1, mouse.y));

                lastTouchX = touch.clientX;
                lastTouchY = touch.clientY;
            }
        }

        function onTouchEnd(e) {
            isTouching = false;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            calculateGameBounds();
        }

        function calculateDifficulty() {
            const progress = crystalsCaught / CONFIG.totalCrystals;
            currentSpeed = CONFIG.baseSpeed + (progress * progress) * (CONFIG.maxSpeed - CONFIG.baseSpeed);
            const chaosFactor = Math.max(0, (progress - 0.2) * 1.25); 
            if (highSpeedParticles) highSpeedParticles.material.opacity = chaosFactor * 0.6;
            debrisObjects.forEach(obj => { obj.material.opacity = chaosFactor * 0.5; });
        }

        function updateStageVisuals() {
            if (currentStage === 0) { 
                tunnel.children.forEach(l => l.material.color.setHex(CONFIG.colors.neonBlue));
                scene.fog.color.setHex(CONFIG.colors.void);
                playerCore.material.emissive.setHex(CONFIG.colors.neonBlue);
            } else if (currentStage === 1) { 
                tunnel.children.forEach((l, i) => { l.material.color.setHex(i % 2 === 0 ? CONFIG.colors.neonBlue : CONFIG.colors.white); });
                playerCore.material.emissive.setHex(CONFIG.colors.white);
            } else if (currentStage === 2) { 
                tunnel.children.forEach(l => l.material.color.setHex(CONFIG.colors.neonRed));
                scene.fog.color.setHex(0x110000); 
                playerCore.material.emissive.setHex(CONFIG.colors.neonRed);
            }
        }

        function spawnCrystal() {
            if (crystalsSpawned >= CONFIG.totalCrystals || crystals.length > 0) return;
            crystalsSpawned++;
            let newStage = crystalsCaught >= 90 ? 2 : (crystalsCaught >= 70 ? 1 : 0);
            let color = [CONFIG.colors.neonBlue, CONFIG.colors.white, CONFIG.colors.neonRed][newStage];

            if (newStage !== currentStage) {
                currentStage = newStage;
                updateStageVisuals();
            }
            
            const mesh = new THREE.Mesh(new THREE.IcosahedronGeometry(1.2, 1), new THREE.MeshBasicMaterial({ color: color, wireframe: true, transparent: true, opacity: 0.8 }));
            const angle = Math.random() * Math.PI * 2;
            const r = Math.random() * 8; 
            mesh.position.set(Math.cos(angle) * r, Math.sin(angle) * r, -120);
            mesh.userData = { id: crystalsSpawned, rotSpeed: new THREE.Vector3(Math.random()*0.05, Math.random()*0.05, Math.random()*0.05) };
            scene.add(mesh);
            crystals.push(mesh);
        }

        function handlePlayer(dt) {
            targetPosition.set(mouse.x * bounds.x, mouse.y * bounds.y);
            const lerpFactor = 1 - Math.pow(0.001, dt); 
            player.position.x += (targetPosition.x - player.position.x) * lerpFactor;
            player.position.y += (targetPosition.y - player.position.y) * lerpFactor;

            player.rotation.z -= currentSpeed * 0.05 * dt * 60;
            player.rotation.x = player.position.y * 0.2;
            player.rotation.y = player.position.x * 0.2;
            
            const pulse = 1 + Math.sin(gameTime * (2 + currentSpeed * 0.5)) * 0.1;
            playerCore.scale.set(pulse, pulse, pulse);
            player.children.forEach(child => { 
                if(child.userData.rotSpeed) child.rotation.z += child.userData.rotSpeed * dt * 60; 
            });
        }

        function checkCollisions(dt) {
            const playerBox = new THREE.Box3().setFromObject(player).expandByScalar(0.1); 
            for (let i = crystals.length - 1; i >= 0; i--) {
                const cry = crystals[i];
                cry.position.z += currentSpeed * dt * 60;
                cry.rotation.x += cry.userData.rotSpeed.x * dt * 60; 
                cry.rotation.y += cry.userData.rotSpeed.y * dt * 60; 
                cry.rotation.z += cry.userData.rotSpeed.z * dt * 60;

                if (new THREE.Box3().setFromObject(cry).intersectsBox(playerBox)) {
                    catchCrystal(cry, i);
                } else if (cry.position.z > 10) {
                    missCrystal(cry, i);
                }
            }
        }

        function catchCrystal(mesh, index) {
            createScatteredImpact(mesh.position, mesh.material.color);
            scene.remove(mesh);
            crystals.splice(index, 1);
            crystalsCaught++;
            updateHUD(); calculateDifficulty();
            shakeIntensity = 0.6; nextSpawnCooldown = 1; 

            if (crystalsCaught === 100) {
                isAscending = true;
                setTimeout(finishGame, 2000);
            } else if (crystalsCaught % 20 === 0) {
                const idx = (crystalsCaught / 20) - 1;
                showMessage(ACHIEVEMENT_TITLES[idx], ACHIEVEMENT_SUBS[idx], 1500);
            }
            checkWinCondition();
        }

        function missCrystal(mesh, index) {
            scene.remove(mesh);
            crystals.splice(index, 1);
            renderer.setClearColor(CONFIG.colors.neonRed, 0.3);
            setTimeout(() => renderer.setClearColor(CONFIG.colors.void, 0), 100);
            nextSpawnCooldown = 1; checkWinCondition();
        }

        function createScatteredImpact(pos, color) {
            const count = 40;
            const geo = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);
            const vels = [];
            for(let i=0; i<count; i++) {
                positions[i*3] = pos.x; positions[i*3+1] = pos.y; positions[i*3+2] = pos.z;
                vels.push(new THREE.Vector3((Math.random()-0.5), (Math.random()-0.5), (Math.random()-0.5)).normalize().multiplyScalar(Math.random()*2+1));
            }
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const ps = new THREE.Points(geo, new THREE.PointsMaterial({ color: color, size: 0.4, transparent: true, opacity: 1.0, blending: THREE.AdditiveBlending }));
            ps.userData = { velocities: vels, life: 1.0, type: 'scatter' };
            scene.add(ps); particleSystems.push(ps);
        }

        function updateParticles(dt) {
            const decay = (0.03 + (currentSpeed * 0.025)) * dt * 60;
            for(let i=particleSystems.length-1; i>=0; i--) {
                const ps = particleSystems[i];
                ps.userData.life -= decay;
                if (ps.userData.type === 'scatter') {
                    const pos = ps.geometry.attributes.position.array;
                    for(let j=0; j<ps.userData.velocities.length; j++) {
                        pos[j*3] += ps.userData.velocities[j].x * dt * 60; 
                        pos[j*3+1] += ps.userData.velocities[j].y * dt * 60; 
                        pos[j*3+2] += ps.userData.velocities[j].z * dt * 60;
                    }
                    ps.geometry.attributes.position.needsUpdate = true;
                    ps.material.opacity = ps.userData.life;
                }
                if(ps.userData.life <= 0) { scene.remove(ps); particleSystems.splice(i, 1); }
            }
        }

        function updateHUD() {
            document.getElementById('caught-count').innerText = crystalsCaught;
            const pct = (crystalsCaught / CONFIG.totalCrystals) * 100;
            const fill = document.getElementById('awareness-fill');
            fill.style.width = pct + "%";
            let color = [CONFIG.colors.neonBlue, CONFIG.colors.white, CONFIG.colors.neonRed][currentStage < 0 ? 0 : currentStage];
            let hex = "#" + color.toString(16).padStart(6, '0');
            fill.style.background = hex; fill.style.boxShadow = `0 0 10px ${hex}`;
            document.querySelector('.counter-big').style.textShadow = `0 0 20px ${hex}`;
        }

        function showMessage(title, sub, dur) {
            const el = document.getElementById('central-message');
            document.getElementById('msg-title').innerText = title;
            document.getElementById('msg-sub').innerText = sub;
            el.style.opacity = 0.6; setTimeout(() => el.style.opacity = 0, dur);
        }

        function checkWinCondition() { if (crystalsSpawned === CONFIG.totalCrystals && crystals.length === 0 && !isAscending) finishGame(); }

        function finishGame() {
            isPlaying = false; 
            document.exitPointerLock();
            const screen = document.getElementById('end-screen');
            screen.style.display = 'flex';
            setTimeout(() => screen.style.opacity = 1, 100);

            const t1 = document.getElementById('end-title-1');
            const t2 = document.getElementById('end-title-2');
            const msg = document.getElementById('end-message');
            const ai = document.getElementById('ai-insight');
            const cortexBtn = document.getElementById('connect-cortex-btn');
            const restartBtn = document.getElementById('restart-btn');

            if (crystalsCaught === 100) {
                t1.innerText = "ASCENSION"; t2.innerText = "ACHIEVED";
                t1.style.webkitTextFillColor = "#fff"; t2.style.webkitTextFillColor = "#ffd700";
                msg.innerHTML = `<span style="color:#ffd700; font-size: 24px; letter-spacing: 5px;">SOURCE CONNECTED</span>`;
                ai.innerHTML = `WELCOME TO THE CORE TEAM.<br>THE VYZVERSE IS YOURS.`;
                
                cortexBtn.style.display = 'block';
                restartBtn.className = 'secondary-btn';
                restartBtn.innerText = 'Re-Initiate Protocol';
            } else {
                t1.innerText = "SEQUENCE"; t2.innerText = "INCOMPLETE";
                t1.style.webkitTextFillColor = "#fff"; t2.style.webkitTextFillColor = "#fff";
                msg.innerHTML = `<span class="lore-text">FRAGMENTS COLLECTED: <b style="color:#ff0033">${crystalsCaught}</b> / 100</span>`;
                ai.innerText = "MORE FOCUS REQUIRED.";
                
                cortexBtn.style.display = 'none';
                restartBtn.className = 'start-btn';
                restartBtn.innerText = 'Re-Initiate Protocol';
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();

            if (!isPlaying) {
                renderer.render(scene, camera);
                if(tunnel) tunnel.rotation.z += 0.001 * dt * 60; return;
            }
            
            gameTime += dt;
            
            if (isAscending) {
                currentSpeed += 0.08; 
                camera.fov -= 0.6;
                camera.updateProjectionMatrix();
                bloomPass.strength += 0.25;
                tunnel.children.forEach(l => {
                    l.material.color.lerp(new THREE.Color(CONFIG.colors.gold), 0.1);
                    l.material.opacity = 1.0;
                });
            }

            if (crystals.length === 0 && crystalsSpawned < CONFIG.totalCrystals && !isAscending) {
                if (--nextSpawnCooldown <= 0) spawnCrystal();
            }
            
            if (shakeIntensity > 0) {
                camera.position.x = (Math.random()-0.5)*shakeIntensity; camera.position.y = (Math.random()-0.5)*shakeIntensity;
                if((shakeIntensity -= 0.05 * dt * 60) <= 0) { camera.position.set(0,0,8); shakeIntensity = 0; }
            }
            
            handlePlayer(dt); 
            checkCollisions(dt); 
            updateParticles(dt);
            
            tunnel.rotation.z += currentSpeed * 0.001 * dt * 60;
            
            debrisObjects.forEach(obj => { 
                obj.position.z += currentSpeed * 2.0 * dt * 60; 
                if (obj.position.z > 10) obj.position.z = -800; 
            });
            
            if (starSystem) {
                const pos = starSystem.geometry.attributes.position.array;
                for(let i=2; i<pos.length; i+=3) { 
                    pos[i] += currentSpeed * 1.5 * dt * 60; 
                    if(pos[i] > 10) pos[i] = -1000; 
                }
                starSystem.geometry.attributes.position.needsUpdate = true;
            }
            
            if (highSpeedParticles) {
                const pos = highSpeedParticles.geometry.attributes.position.array;
                for(let i=2; i<pos.length; i+=3) { 
                    pos[i] += currentSpeed * 5.0 * dt * 60; 
                    if(pos[i] > 10) pos[i] = -1000; 
                }
                highSpeedParticles.geometry.attributes.position.needsUpdate = true;
            }
            
            if(vyztor) { 
                vyztor.rotation.y += 0.005 * dt * 60; 
                let vColor = [CONFIG.colors.neonBlue, CONFIG.colors.white, CONFIG.colors.neonRed][currentStage < 0 ? 0 : currentStage];
                if(isAscending) vColor = CONFIG.colors.gold;
                vyztor.material.emissive.setHex(vColor); 
            }
            
            composer.render();
        }

        // Action: Connect to Cortex
        document.getElementById('connect-cortex-btn').addEventListener('click', () => {
            const email = CONFIG.winnerEmail;
            const subject = "Ready to enter the VYZ Interstellar Cortex";
            
            // 1. Copy to clipboard
            const textArea = document.createElement("textarea");
            textArea.value = email;
            document.body.appendChild(textArea);
            textArea.select();
            try {
                document.execCommand('copy');
            } catch (err) {}
            document.body.removeChild(textArea);

            // 2. Open Mail Client
            window.location.href = `mailto:${email}?subject=${encodeURIComponent(subject)}`;
        });

        document.getElementById('initial-start-btn').addEventListener('click', () => {
            document.body.requestPointerLock();
            document.getElementById('initial-start-btn').style.display = 'none';
            startProtocol();
        });

        document.getElementById('restart-btn').addEventListener('click', () => {
            document.body.requestPointerLock();
            document.getElementById('end-screen').style.display = 'none';
            startProtocol();
        });

        window.onload = init;
    </script>
</body>
</html>
